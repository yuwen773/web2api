# 技术方案评估：HTTP 逆向 vs 浏览器自动化

## 决策结论

**推荐方案：纯 HTTP + SSE**

本文档详细解释为什么选择 HTTP 逆向而非浏览器自动化（Playwright/Puppeteer）。

---

## 1. 协议复杂度分析

### 1.1 太极AI 的 API 特点

通过抓包分析，太极AI 的通信协议具有以下特征：

| 特征 | 分析 | 影响 |
|------|------|------|
| **认证方式** | 标准 JWT Bearer Token | 🟢 简单 |
| **请求格式** | 标准 JSON | 🟢 简单 |
| **响应格式** | SSE (Server-Sent Events) | 🟡 中等 |
| **Headers** | 仅需 `authorization` 和 `x-app-version` | 🟢 简单 |
| **签名/加密** | 无 | 🟢 简单 |
| **人机验证** | 无 Cloudflare/Turnstile/reCAPTCHA | 🟢 简单 |

**结论**：太极AI 使用的是标准的 RESTful API + SSE，没有复杂的反爬机制。

---

### 1.2 对比其他平台

#### 需要浏览器自动化的平台典型特征：

| 平台 | 技术挑战 | 为什么需要浏览器 |
|------|----------|------------------|
| **ChatGPT (免费版)** | Cloudflare 五秒盾 | 需要浏览器执行 JavaScript 绕过 |
| **ChatGPT (付费版)** | 动态签名参数 (X-Signature) | 需要逆向 JS 或用浏览器执行 |
| **Claude** | 复杂的指纹验证 | 需要完整的浏览器环境 |
| **国内某些平台** | WebSocket + 加密 | 协议复杂，逆向成本高 |

#### 太极AI vs 这些平台：

```
太极AI:       HTTP POST → JSON 请求 → SSE 响应 (无加密、无签名)
ChatGPT:      浏览器 → Cloudflare 验证 → JavaScript 计算签名 → API
Claude:       浏览器 → TLS 指纹验证 → WebSocket → 加密数据流
```

**明显区别**：太极AI 没有任何需要浏览器才能处理的障碍。

---

## 2. 方案对比

### 方案 A：纯 HTTP + SSE（推荐）

#### 实现方式
```python
# 伪代码示例
import httpx

async with httpx.AsyncClient() as client:
    # 1. 登录获取 token
    response = await client.post("/api/user/login", json={...})
    token = response.json()["data"]["token"]

    # 2. 发送消息
    async with client.stream(
        "POST",
        "/api/chat/completions",
        headers={"authorization": f"Bearer {token}"},
        json={"text": "hello", "sessionId": 123}
    ) as stream:
        async for chunk in stream.aiter_lines():
            # 处理 SSE 数据
            pass
```

#### 优点

| 维度 | 优势说明 |
|------|----------|
| **性能** | HTTP 请求延迟极低（毫秒级），无需启动浏览器 |
| **资源占用** | 内存占用 < 50MB，CPU 占用极低 |
| **并发能力** | 可轻松处理数百并发请求 |
| **稳定性** | 无浏览器崩溃风险，进程更稳定 |
| **部署** | 无需安装 Chrome/Chromium，Docker 镜像小（< 100MB） |
| **代码复杂度** | 代码量少，逻辑清晰，易于维护 |
| **开发速度** | 无需处理浏览器自动化的问题，开发快 |
| **成本** | 可运行在最低配置的服务器上（1核1G） |

#### 缺点

| 缺点 | 应对方案 |
|------|----------|
| API 变化可能失效 | 太极AI 是套壳平台，API 变化相对缓慢；且修改 HTTP 代码比浏览器代码更简单 |
| 无法处理复杂验证 | 太极AI 无复杂验证，此缺点不适用 |

---

### 方案 B：浏览器自动化（Playwright/Puppeteer）

#### 实现方式
```python
# 伪代码示例
from playwright.async_api import async_playwright

async with async_playwright() as p:
    # 1. 启动浏览器
    browser = await p.chromium.launch()
    page = await browser.new_page()

    # 2. 注入 token 或登录
    await page.goto("https://ai.aurod.cn/chat")
    await page.evaluate(f"localStorage.setItem('token', '{token}')")

    # 3. 拦截网络请求或模拟页面操作
    async with page.expect_response("**/api/chat/completions") as response:
        await page.fill("textarea", "hello")
        await page.click("button[type='submit']")

    # 4. 读取响应
    data = await response.value.body()
```

#### 优点

| 优势 | 适用场景 |
|------|----------|
| 通用性强 | 适用于任何网页，无论 API 多复杂 |
| 可处理前端渲染 | 如果页面是 SPA，需要 JS 才能显示内容 |
| 可绕过某些验证 | 如 Cloudflare（需配合 stealth 插件） |

#### 缺点

| 维度 | 劣势说明 |
|------|----------|
| **性能** | 需启动浏览器，首次请求延迟高（秒级） |
| **资源占用** | 每个浏览器实例占用 200-500MB 内存 |
| **并发限制** | 单机并发受内存限制，通常 < 50 |
| **稳定性** | 浏览器可能崩溃，页面可能卡死 |
| **部署复杂** | 需安装浏览器依赖，Docker 镜像大（> 1GB） |
| **代码复杂度** | 需处理页面加载、元素定位、超时等问题 |
| **维护成本** | 页面 DOM 变化需要更新选择器 |
| **成本** | 需要更高配置的服务器（2核4G 起步） |

---

## 3. 具体对比表

### 资源消耗对比

| 指标 | HTTP 方案 | 浏览器方案 | 差距 |
|------|-----------|------------|------|
| 内存占用 | ~30MB | ~300MB | **10倍** |
| CPU 占用 | < 1% | 5-15% | **5-15倍** |
| 磁盘空间 | ~50MB (Docker) | ~1GB (Docker) | **20倍** |
| 首次请求延迟 | ~100ms | ~2s | **20倍** |
| 启动时间 | < 1s | ~5s | **5倍** |

### 并发能力对比

| 并发数 | HTTP 方案 | 浏览器方案 |
|--------|-----------|------------|
| 10 | ✅ 轻松应对 | ✅ 可以 |
| 50 | ✅ 轻松应对 | ⚠️ 需要 2-4GB 内存 |
| 100 | ✅ 轻松应对 | ❌ 需要多台服务器 |
| 500 | ✅ 轻松应对 | ❌ 不现实 |

### 开发维护对比

| 方面 | HTTP 方案 | 浏览器方案 |
|------|-----------|------------|
| 代码行数 | ~500 行 | ~1000 行 |
| 开发时间 | 10-16 小时 | 20-30 小时 |
| 调试难度 | 低（直接看 HTTP 报文） | 高（需要截图、日志） |
| API 变化维护 | 修改 JSON 结构 | 修改页面选择器 |
| 依赖更新 | pip install | pip + 浏览器版本 |

---

## 4. 风险评估

### HTTP 方案的风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| API 格式变化 | 中 | 中 | 代码结构清晰，易于修改 |
| 添加签名验证 | 低 | 高 | 届时可切换到浏览器方案 |
| 添加人机验证 | 低 | 高 | 同上 |

### 浏览器方案的风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 页面 DOM 变化 | 高 | 中 | 需要更新选择器 |
| 浏览器版本兼容 | 中 | 中 | 需要维护多版本 |
| 资源耗尽 | 中 | 高 | 需要更多服务器 |

---

## 5. 成本对比

### 自用场景（1-5 人）

| 方案 | 服务器配置 | 月成本（按最便宜云） |
|------|------------|---------------------|
| HTTP | 1核1G | ~¥30/月 |
| 浏览器 | 2核4G | ~¥100/月 |

**HTTP 方案节省 70% 成本**

### 小团队场景（10-50 人）

| 方案 | 所需服务器 | 月成本 |
|------|------------|--------|
| HTTP | 1 台 1核2G | ~¥50/月 |
| 浏览器 | 2-3 台 2核4G | ~¥300/月 |

**HTTP 方案节省 83% 成本**

---

## 6. 什么时候应该用浏览器方案？

**仅在以下情况考虑浏览器自动化：**

1. ✅ API 有 Cloudflare/Turnstile 等人机验证
2. ✅ 请求有动态签名，逆向成本极高
3. ✅ 协议是 WebSocket 且数据加密
4. ✅ 需要处理页面渲染才能获取数据
5. ✅ API 是完全私有的，且变化频繁

**太极AI 不具备以上任何特征。**

---

## 7. 最终决策矩阵

| 评估维度 | HTTP 方案 | 浏览器方案 | 权重 | 胜者 |
|----------|-----------|------------|------|------|
| 实现难度 | ⭐⭐ 简单 | ⭐⭐⭐⭐ 复杂 | 30% | **HTTP** |
| 性能表现 | ⭐⭐⭐⭐⭐ 优秀 | ⭐⭐ 一般 | 20% | **HTTP** |
| 资源消耗 | ⭐⭐⭐⭐⭐ 极低 | ⭐⭐ 高 | 15% | **HTTP** |
| 可维护性 | ⭐⭐⭐⭐⭐ 易维护 | ⭐⭐⭐ 中等 | 15% | **HTTP** |
| 部署简易性 | ⭐⭐⭐⭐⭐ 简单 | ⭐⭐⭐ 中等 | 10% | **HTTP** |
| 通用性 | ⭐⭐⭐ 特定场景 | ⭐⭐⭐⭐⭐ 万能 | 10% | 浏览器 |

**综合得分**：HTTP 方案 **4.65/5.0** vs 浏览器方案 **2.75/5.0**

---

## 8. 结论

基于以上分析：

1. ✅ **太极AI 的 API 简单清晰**，无任何需要浏览器才能处理的障碍
2. ✅ **HTTP 方案在所有关键维度上优于浏览器方案**
3. ✅ **HTTP 方案成本仅为浏览器方案的 20-30%**
4. ✅ **开发时间减少 50%，维护成本更低**
5. ⚠️ 唯一缺点是通用性稍差，但太极AI 不需要此优势

**最终建议：优先使用纯 HTTP + SSE 方案。**

如果未来太极AI 添加了复杂的反爬机制（概率很低），再考虑切换到浏览器方案也不迟。届时由于业务逻辑已经清晰，切换成本也不会太高。

---

## 附录：技术选型速查表

| 特征 | 推荐方案 | 原因 |
|------|----------|------|
| 标准 REST API | HTTP | 最简单直接 |
| JWT 认证 | HTTP | 无需浏览器状态 |
| SSE 响应 | HTTP | 原生支持 |
| 无签名验证 | HTTP | 省去逆向工作 |
| 无人机验证 | HTTP | 无需绕过 |
| 代码量少 | HTTP | 更易维护 |
| 低配置服务器 | HTTP | 资源占用低 |

| 特征 | 推荐方案 | 原因 |
|------|----------|------|
| Cloudflare 验证 | 浏览器 | 需要执行 JS |
| 动态签名参数 | 浏览器 | 逆向成本高 |
| 复杂 WebSocket | 浏览器 | 直接复用连接 |
| SPA 页面抓取 | 浏览器 | 需要等待渲染 |
| 频繁变化的 DOM | 浏览器 | 用选择器更灵活 |

**太极AI 完全符合左侧表格的特征。**
